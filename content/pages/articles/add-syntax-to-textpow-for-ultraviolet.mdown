Date: 18 June, 2013
Categories: categories/ruby, categories/nesta
Summary: While using Nestacms, I wanted to add a new syntax to Textpow and Ultraviolet for parsing some varnish configuration language files (or vcl files) to display on my web site. My adventure on this turned out to be easy once I realized how cool Nesta really is!

# Add new syntax into Nestacms for use with Ultraviolet and Textpow

## How to start

Make sure you have all the necessary changes to Nestacms for [Setting up rack-codehighligher with Nestacms][rack_article].

## Converting a Textmate Syntax bundle

Download the bundle (usually from a github respository) to get ready for conversion. Once you have the `Language.tmLanguage` convert the language file to a yaml file which should end up with a file name like `source.Language.syntax` by using this command:

    :::shell
    plist2yaml Language.tmLanguage > source.Language.syntax

If you get an error like the following you need to be inside the `Language.tmbundle/Syntaxes` directory where the `.tmLanuage` file is located:

    :::shell
    /Users/aaron/.rvm/gems/ruby-1.9.2-p320/gems/plist-3.1.0/lib/plist/parser.rb:67:in `read': Is a directory - Varnish.tmbundle (Errno::EISDIR)
      from /Users/aaron/.rvm/gems/ruby-1.9.2-p320/gems/plist-3.1.0/lib/plist/parser.rb:67:in `initialize'
      from /Users/aaron/.rvm/gems/ruby-1.9.2-p320/gems/plist-3.1.0/lib/plist/parser.rb:28:in `new'
      from /Users/aaron/.rvm/gems/ruby-1.9.2-p320/gems/plist-3.1.0/lib/plist/parser.rb:28:in `parse_xml'
      from /Users/aaron/.rvm/gems/ruby-1.9.2-p320/gems/textpow-1.3.0/bin/plist2yaml:7:in `<top (required)>'
      from /Users/aaron/.rvm/gems/ruby-1.9.2-p320/bin/plist2yaml:19:in `load'
      from /Users/aaron/.rvm/gems/ruby-1.9.2-p320/bin/plist2yaml:19:in `<main>'
      from /Users/aaron/.rvm/gems/ruby-1.9.2-p320/bin/ruby_noexec_wrapper:14:in `eval'
      from /Users/aaron/.rvm/gems/ruby-1.9.2-p320/bin/ruby_noexec_wrapper:14:in `<main>'

## Load the syntax file into Nestacms

By adding the following code into your app.rb file the syntax will be available:

    :::ruby
    Textpow::SyntaxNode.load(File.expand_path('public/syntaxes/source.vcl.syntax', Nesta::App.root))

## Use the syntax on you files

To apply the syntax I came up with some code for printing code from the `app.rb` file by making this method:

    :::ruby
    # load custom syntaxes
    Textpow::SyntaxNode.load(File.expand_path('public/syntaxes/source.vcl.syntax', Nesta::App.root))

    def print_code(opt={})
      filename = opt[:filename]
      theme = opt[:theme] || "brilliance_black"
      syntax = opt[:syntax]
      show_code = opt[:show_code] || true

      text = File.read(Dir.pwd + '/public/' + filename)
      processor = Textpow::RecordingProcessor.new
      result = Uv.parse( text, "xhtml", syntax, false, "eiffel")

      haml(:print_code, :layout => false, :locals => { :code => result, :filename => filename })

      case show_code
      when true
        return haml(:print_code, :layout => false, :locals => { :code => result, :filename => filename })
      when false
        return download_link
      end
    end

Now when you want to call some code, make a `haml` file and include the file with the following:

    :::shell
    = print_code("file_with_language.vcl")

# Notes

To list the availble syntaxes:

    :::shell
    uv --list syntaxes

# Further investigation

I would like to make this soltion more elegant and add the syntax file for being parsed while not having to install the file to the gem or having to call the syntax file each time with its full path.

So far I have a feeling that it has to do with the following code:

    :::ruby
    #encoding: ascii-8bit
    require 'fileutils'
    require 'textpow'
    require 'uv/render_processor.rb'
      
    
    module Uv
      class << self
        attr_accessor :render_path, :theme_path, :syntax_path, :default_style, :syntaxes
      end
      
      self.syntax_path   = File.join(File.dirname(__FILE__), '..', 'syntax')
      self.render_path   = File.join(File.dirname(__FILE__), '..', 'render')
      self.theme_path    = File.join(render_path, 'xhtml', 'files', 'css')
      self.default_style = 'mac_classic'
      self.syntaxes      = {}
      
      def Uv.path
        result = []
        result << File.join(File.dirname(__FILE__), ".." )
      end
      
      def self.syntax_node_for(syntax)
        if !@syntaxes.key?(syntax)
          filename = File.join(@syntax_path, "#{syntax}.syntax")
          @syntaxes[syntax] = if File.exist?(filename)
            Textpow::SyntaxNode.load(filename)
          else
            false
          end
        end
        if !@syntaxes[syntax]
          raise ArgumentError, "No #{syntax}.syntax file in #{@syntax_path}"
        end
        @syntaxes[syntax]
      end
      
      def Uv.copy_files output, output_dir
        Uv.path.each do |dir|
          dir_name = File.join( dir, "render", output, "files" )
          FileUtils.cp_r( Dir.glob(File.join( dir_name, "." )), output_dir ) if File.exists?( dir_name )
        end
      end
      
      def Uv.syntaxes
        Dir.glob( File.join(@syntax_path, '*.syntax') ).collect do |f| 
          File.basename(f, '.syntax')
        end
      end
      
      def Uv.themes
        Dir.glob( File.join(@theme_path, '*.css') ).collect do |f| 
          File.basename(f, '.css')
        end
      end
      
      def Uv.syntax_for_file file_name
        init_syntaxes unless @syntaxes
        first_line = ""
        File.open( file_name, 'r' ) { |f|
          while (first_line = f.readline).strip.size == 0; end
        }
        result = []
        @syntaxes.each do |key, value|
          assigned = false
          if value.fileTypes
            value.fileTypes.each do |t|
              if t == File.basename( file_name ) || t == File.extname( file_name )[1..-1]
                result << [key, value] 
                assigned = true
                break
              end
            end
          end
          unless assigned
            if value.firstLineMatch && value.firstLineMatch =~ first_line
              result << [key, value] 
            end
          end
        end
        result
      end
      
      def Uv.parse text, output = "xhtml", syntax_name = nil, line_numbers = false, render_style = nil, headers = false
        RenderProcessor.load(output, render_style, line_numbers, headers) do |processor|
          syntax_node_for(syntax_name).parse(text, processor)
        end.string
      end
      
      def Uv.debug text, syntax_name
        syntax_node_for(syntax_name).parse(text, Textpow::DebugProcessor.new)
      end
      
    end
[rack_article]: /articles/rack-codehighligher
